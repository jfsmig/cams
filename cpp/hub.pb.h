// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hub.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hub_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hub_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hub_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hub_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hub_2eproto;
namespace cams {
namespace api {
namespace hub {
class DownstreamControlRequest;
struct DownstreamControlRequestDefaultTypeInternal;
extern DownstreamControlRequestDefaultTypeInternal _DownstreamControlRequest_default_instance_;
class DownstreamMediaFrame;
struct DownstreamMediaFrameDefaultTypeInternal;
extern DownstreamMediaFrameDefaultTypeInternal _DownstreamMediaFrame_default_instance_;
class None;
struct NoneDefaultTypeInternal;
extern NoneDefaultTypeInternal _None_default_instance_;
class PauseRequest;
struct PauseRequestDefaultTypeInternal;
extern PauseRequestDefaultTypeInternal _PauseRequest_default_instance_;
class PlayRequest;
struct PlayRequestDefaultTypeInternal;
extern PlayRequestDefaultTypeInternal _PlayRequest_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StreamId;
struct StreamIdDefaultTypeInternal;
extern StreamIdDefaultTypeInternal _StreamId_default_instance_;
}  // namespace hub
}  // namespace api
}  // namespace cams
PROTOBUF_NAMESPACE_OPEN
template<> ::cams::api::hub::DownstreamControlRequest* Arena::CreateMaybeMessage<::cams::api::hub::DownstreamControlRequest>(Arena*);
template<> ::cams::api::hub::DownstreamMediaFrame* Arena::CreateMaybeMessage<::cams::api::hub::DownstreamMediaFrame>(Arena*);
template<> ::cams::api::hub::None* Arena::CreateMaybeMessage<::cams::api::hub::None>(Arena*);
template<> ::cams::api::hub::PauseRequest* Arena::CreateMaybeMessage<::cams::api::hub::PauseRequest>(Arena*);
template<> ::cams::api::hub::PlayRequest* Arena::CreateMaybeMessage<::cams::api::hub::PlayRequest>(Arena*);
template<> ::cams::api::hub::RegisterRequest* Arena::CreateMaybeMessage<::cams::api::hub::RegisterRequest>(Arena*);
template<> ::cams::api::hub::Status* Arena::CreateMaybeMessage<::cams::api::hub::Status>(Arena*);
template<> ::cams::api::hub::StreamId* Arena::CreateMaybeMessage<::cams::api::hub::StreamId>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cams {
namespace api {
namespace hub {

enum DownstreamCommandType : int {
  DOWNSTREAM_COMMAND_TYPE_UNSPECIFIED = 0,
  DOWNSTREAM_COMMAND_TYPE_PLAY = 1,
  DOWNSTREAM_COMMAND_TYPE_STOP = 2,
  DownstreamCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownstreamCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownstreamCommandType_IsValid(int value);
constexpr DownstreamCommandType DownstreamCommandType_MIN = DOWNSTREAM_COMMAND_TYPE_UNSPECIFIED;
constexpr DownstreamCommandType DownstreamCommandType_MAX = DOWNSTREAM_COMMAND_TYPE_STOP;
constexpr int DownstreamCommandType_ARRAYSIZE = DownstreamCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownstreamCommandType_descriptor();
template<typename T>
inline const std::string& DownstreamCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownstreamCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownstreamCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownstreamCommandType_descriptor(), enum_t_value);
}
inline bool DownstreamCommandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownstreamCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownstreamCommandType>(
    DownstreamCommandType_descriptor(), name, value);
}
enum DownstreamMediaFrameType : int {
  DOWNSTREAM_MEDIA_FRAME_TYPE_UNSPECIFIED = 0,
  DOWNSTREAM_MEDIA_FRAME_TYPE_RTP = 1,
  DOWNSTREAM_MEDIA_FRAME_TYPE_RTCP = 2,
  DOWNSTREAM_MEDIA_FRAME_TYPE_SDP = 3,
  DownstreamMediaFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownstreamMediaFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownstreamMediaFrameType_IsValid(int value);
constexpr DownstreamMediaFrameType DownstreamMediaFrameType_MIN = DOWNSTREAM_MEDIA_FRAME_TYPE_UNSPECIFIED;
constexpr DownstreamMediaFrameType DownstreamMediaFrameType_MAX = DOWNSTREAM_MEDIA_FRAME_TYPE_SDP;
constexpr int DownstreamMediaFrameType_ARRAYSIZE = DownstreamMediaFrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownstreamMediaFrameType_descriptor();
template<typename T>
inline const std::string& DownstreamMediaFrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownstreamMediaFrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownstreamMediaFrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownstreamMediaFrameType_descriptor(), enum_t_value);
}
inline bool DownstreamMediaFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownstreamMediaFrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownstreamMediaFrameType>(
    DownstreamMediaFrameType_descriptor(), name, value);
}
// ===================================================================

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cams.api.hub.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class StreamId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.StreamId) */ {
 public:
  inline StreamId() : StreamId(nullptr) {}
  ~StreamId() override;
  explicit PROTOBUF_CONSTEXPR StreamId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamId(const StreamId& from);
  StreamId(StreamId&& from) noexcept
    : StreamId() {
    *this = ::std::move(from);
  }

  inline StreamId& operator=(const StreamId& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamId& operator=(StreamId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamId& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamId* internal_default_instance() {
    return reinterpret_cast<const StreamId*>(
               &_StreamId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StreamId& a, StreamId& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamId& from) {
    StreamId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.StreamId";
  }
  protected:
  explicit StreamId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kStreamFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string stream = 2;
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // @@protoc_insertion_point(class_scope:cams.api.hub.StreamId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class None final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cams.api.hub.None) */ {
 public:
  inline None() : None(nullptr) {}
  explicit PROTOBUF_CONSTEXPR None(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  None(const None& from);
  None(None&& from) noexcept
    : None() {
    *this = ::std::move(from);
  }

  inline None& operator=(const None& from) {
    CopyFrom(from);
    return *this;
  }
  inline None& operator=(None&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const None& default_instance() {
    return *internal_default_instance();
  }
  static inline const None* internal_default_instance() {
    return reinterpret_cast<const None*>(
               &_None_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(None& a, None& b) {
    a.Swap(&b);
  }
  inline void Swap(None* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(None* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  None* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<None>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const None& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const None& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.None";
  }
  protected:
  explicit None(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cams.api.hub.None)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class DownstreamControlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.DownstreamControlRequest) */ {
 public:
  inline DownstreamControlRequest() : DownstreamControlRequest(nullptr) {}
  ~DownstreamControlRequest() override;
  explicit PROTOBUF_CONSTEXPR DownstreamControlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownstreamControlRequest(const DownstreamControlRequest& from);
  DownstreamControlRequest(DownstreamControlRequest&& from) noexcept
    : DownstreamControlRequest() {
    *this = ::std::move(from);
  }

  inline DownstreamControlRequest& operator=(const DownstreamControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownstreamControlRequest& operator=(DownstreamControlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownstreamControlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownstreamControlRequest* internal_default_instance() {
    return reinterpret_cast<const DownstreamControlRequest*>(
               &_DownstreamControlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownstreamControlRequest& a, DownstreamControlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownstreamControlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownstreamControlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownstreamControlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownstreamControlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownstreamControlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownstreamControlRequest& from) {
    DownstreamControlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownstreamControlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.DownstreamControlRequest";
  }
  protected:
  explicit DownstreamControlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIDFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // string streamID = 1;
  void clear_streamid();
  const std::string& streamid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_streamid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_streamid();
  PROTOBUF_NODISCARD std::string* release_streamid();
  void set_allocated_streamid(std::string* streamid);
  private:
  const std::string& _internal_streamid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamid(const std::string& value);
  std::string* _internal_mutable_streamid();
  public:

  // .cams.api.hub.DownstreamCommandType command = 2;
  void clear_command();
  ::cams::api::hub::DownstreamCommandType command() const;
  void set_command(::cams::api::hub::DownstreamCommandType value);
  private:
  ::cams::api::hub::DownstreamCommandType _internal_command() const;
  void _internal_set_command(::cams::api::hub::DownstreamCommandType value);
  public:

  // @@protoc_insertion_point(class_scope:cams.api.hub.DownstreamControlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr streamid_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class DownstreamMediaFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.DownstreamMediaFrame) */ {
 public:
  inline DownstreamMediaFrame() : DownstreamMediaFrame(nullptr) {}
  ~DownstreamMediaFrame() override;
  explicit PROTOBUF_CONSTEXPR DownstreamMediaFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownstreamMediaFrame(const DownstreamMediaFrame& from);
  DownstreamMediaFrame(DownstreamMediaFrame&& from) noexcept
    : DownstreamMediaFrame() {
    *this = ::std::move(from);
  }

  inline DownstreamMediaFrame& operator=(const DownstreamMediaFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownstreamMediaFrame& operator=(DownstreamMediaFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownstreamMediaFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownstreamMediaFrame* internal_default_instance() {
    return reinterpret_cast<const DownstreamMediaFrame*>(
               &_DownstreamMediaFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DownstreamMediaFrame& a, DownstreamMediaFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DownstreamMediaFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownstreamMediaFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownstreamMediaFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownstreamMediaFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownstreamMediaFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownstreamMediaFrame& from) {
    DownstreamMediaFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownstreamMediaFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.DownstreamMediaFrame";
  }
  protected:
  explicit DownstreamMediaFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .cams.api.hub.DownstreamMediaFrameType type = 2;
  void clear_type();
  ::cams::api::hub::DownstreamMediaFrameType type() const;
  void set_type(::cams::api::hub::DownstreamMediaFrameType value);
  private:
  ::cams::api::hub::DownstreamMediaFrameType _internal_type() const;
  void _internal_set_type(::cams::api::hub::DownstreamMediaFrameType value);
  public:

  // @@protoc_insertion_point(class_scope:cams.api.hub.DownstreamMediaFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .cams.api.hub.StreamId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::cams::api::hub::StreamId& id() const;
  PROTOBUF_NODISCARD ::cams::api::hub::StreamId* release_id();
  ::cams::api::hub::StreamId* mutable_id();
  void set_allocated_id(::cams::api::hub::StreamId* id);
  private:
  const ::cams::api::hub::StreamId& _internal_id() const;
  ::cams::api::hub::StreamId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::cams::api::hub::StreamId* id);
  ::cams::api::hub::StreamId* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:cams.api.hub.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cams::api::hub::StreamId* id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class PlayRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.PlayRequest) */ {
 public:
  inline PlayRequest() : PlayRequest(nullptr) {}
  ~PlayRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayRequest(const PlayRequest& from);
  PlayRequest(PlayRequest&& from) noexcept
    : PlayRequest() {
    *this = ::std::move(from);
  }

  inline PlayRequest& operator=(const PlayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayRequest& operator=(PlayRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayRequest* internal_default_instance() {
    return reinterpret_cast<const PlayRequest*>(
               &_PlayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlayRequest& a, PlayRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayRequest& from) {
    PlayRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.PlayRequest";
  }
  protected:
  explicit PlayRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .cams.api.hub.StreamId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::cams::api::hub::StreamId& id() const;
  PROTOBUF_NODISCARD ::cams::api::hub::StreamId* release_id();
  ::cams::api::hub::StreamId* mutable_id();
  void set_allocated_id(::cams::api::hub::StreamId* id);
  private:
  const ::cams::api::hub::StreamId& _internal_id() const;
  ::cams::api::hub::StreamId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::cams::api::hub::StreamId* id);
  ::cams::api::hub::StreamId* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:cams.api.hub.PlayRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cams::api::hub::StreamId* id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// -------------------------------------------------------------------

class PauseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cams.api.hub.PauseRequest) */ {
 public:
  inline PauseRequest() : PauseRequest(nullptr) {}
  ~PauseRequest() override;
  explicit PROTOBUF_CONSTEXPR PauseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseRequest(const PauseRequest& from);
  PauseRequest(PauseRequest&& from) noexcept
    : PauseRequest() {
    *this = ::std::move(from);
  }

  inline PauseRequest& operator=(const PauseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseRequest& operator=(PauseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseRequest* internal_default_instance() {
    return reinterpret_cast<const PauseRequest*>(
               &_PauseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PauseRequest& a, PauseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PauseRequest& from) {
    PauseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cams.api.hub.PauseRequest";
  }
  protected:
  explicit PauseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .cams.api.hub.StreamId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::cams::api::hub::StreamId& id() const;
  PROTOBUF_NODISCARD ::cams::api::hub::StreamId* release_id();
  ::cams::api::hub::StreamId* mutable_id();
  void set_allocated_id(::cams::api::hub::StreamId* id);
  private:
  const ::cams::api::hub::StreamId& _internal_id() const;
  ::cams::api::hub::StreamId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::cams::api::hub::StreamId* id);
  ::cams::api::hub::StreamId* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:cams.api.hub.PauseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cams::api::hub::StreamId* id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hub_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Status

// uint32 code = 1;
inline void Status::clear_code() {
  _impl_.code_ = 0u;
}
inline uint32_t Status::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t Status::code() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.Status.code)
  return _internal_code();
}
inline void Status::_internal_set_code(uint32_t value) {
  
  _impl_.code_ = value;
}
inline void Status::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:cams.api.hub.Status.code)
}

// string status = 2;
inline void Status::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& Status::status() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.Status.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cams.api.hub.Status.status)
}
inline std::string* Status::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.Status.status)
  return _s;
}
inline const std::string& Status::_internal_status() const {
  return _impl_.status_.Get();
}
inline void Status::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_status() {
  // @@protoc_insertion_point(field_release:cams.api.hub.Status.status)
  return _impl_.status_.Release();
}
inline void Status::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.Status.status)
}

// -------------------------------------------------------------------

// StreamId

// string user = 1;
inline void StreamId::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& StreamId::user() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.StreamId.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamId::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cams.api.hub.StreamId.user)
}
inline std::string* StreamId::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.StreamId.user)
  return _s;
}
inline const std::string& StreamId::_internal_user() const {
  return _impl_.user_.Get();
}
inline void StreamId::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamId::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamId::release_user() {
  // @@protoc_insertion_point(field_release:cams.api.hub.StreamId.user)
  return _impl_.user_.Release();
}
inline void StreamId::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.StreamId.user)
}

// string stream = 2;
inline void StreamId::clear_stream() {
  _impl_.stream_.ClearToEmpty();
}
inline const std::string& StreamId::stream() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.StreamId.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamId::set_stream(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cams.api.hub.StreamId.stream)
}
inline std::string* StreamId::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.StreamId.stream)
  return _s;
}
inline const std::string& StreamId::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void StreamId::_internal_set_stream(const std::string& value) {
  
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamId::_internal_mutable_stream() {
  
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamId::release_stream() {
  // @@protoc_insertion_point(field_release:cams.api.hub.StreamId.stream)
  return _impl_.stream_.Release();
}
inline void StreamId::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.StreamId.stream)
}

// -------------------------------------------------------------------

// None

// -------------------------------------------------------------------

// DownstreamControlRequest

// string streamID = 1;
inline void DownstreamControlRequest::clear_streamid() {
  _impl_.streamid_.ClearToEmpty();
}
inline const std::string& DownstreamControlRequest::streamid() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.DownstreamControlRequest.streamID)
  return _internal_streamid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownstreamControlRequest::set_streamid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.streamid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cams.api.hub.DownstreamControlRequest.streamID)
}
inline std::string* DownstreamControlRequest::mutable_streamid() {
  std::string* _s = _internal_mutable_streamid();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.DownstreamControlRequest.streamID)
  return _s;
}
inline const std::string& DownstreamControlRequest::_internal_streamid() const {
  return _impl_.streamid_.Get();
}
inline void DownstreamControlRequest::_internal_set_streamid(const std::string& value) {
  
  _impl_.streamid_.Set(value, GetArenaForAllocation());
}
inline std::string* DownstreamControlRequest::_internal_mutable_streamid() {
  
  return _impl_.streamid_.Mutable(GetArenaForAllocation());
}
inline std::string* DownstreamControlRequest::release_streamid() {
  // @@protoc_insertion_point(field_release:cams.api.hub.DownstreamControlRequest.streamID)
  return _impl_.streamid_.Release();
}
inline void DownstreamControlRequest::set_allocated_streamid(std::string* streamid) {
  if (streamid != nullptr) {
    
  } else {
    
  }
  _impl_.streamid_.SetAllocated(streamid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamid_.IsDefault()) {
    _impl_.streamid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.DownstreamControlRequest.streamID)
}

// .cams.api.hub.DownstreamCommandType command = 2;
inline void DownstreamControlRequest::clear_command() {
  _impl_.command_ = 0;
}
inline ::cams::api::hub::DownstreamCommandType DownstreamControlRequest::_internal_command() const {
  return static_cast< ::cams::api::hub::DownstreamCommandType >(_impl_.command_);
}
inline ::cams::api::hub::DownstreamCommandType DownstreamControlRequest::command() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.DownstreamControlRequest.command)
  return _internal_command();
}
inline void DownstreamControlRequest::_internal_set_command(::cams::api::hub::DownstreamCommandType value) {
  
  _impl_.command_ = value;
}
inline void DownstreamControlRequest::set_command(::cams::api::hub::DownstreamCommandType value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:cams.api.hub.DownstreamControlRequest.command)
}

// -------------------------------------------------------------------

// DownstreamMediaFrame

// .cams.api.hub.DownstreamMediaFrameType type = 2;
inline void DownstreamMediaFrame::clear_type() {
  _impl_.type_ = 0;
}
inline ::cams::api::hub::DownstreamMediaFrameType DownstreamMediaFrame::_internal_type() const {
  return static_cast< ::cams::api::hub::DownstreamMediaFrameType >(_impl_.type_);
}
inline ::cams::api::hub::DownstreamMediaFrameType DownstreamMediaFrame::type() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.DownstreamMediaFrame.type)
  return _internal_type();
}
inline void DownstreamMediaFrame::_internal_set_type(::cams::api::hub::DownstreamMediaFrameType value) {
  
  _impl_.type_ = value;
}
inline void DownstreamMediaFrame::set_type(::cams::api::hub::DownstreamMediaFrameType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cams.api.hub.DownstreamMediaFrame.type)
}

// bytes payload = 3;
inline void DownstreamMediaFrame::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& DownstreamMediaFrame::payload() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.DownstreamMediaFrame.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownstreamMediaFrame::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cams.api.hub.DownstreamMediaFrame.payload)
}
inline std::string* DownstreamMediaFrame::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.DownstreamMediaFrame.payload)
  return _s;
}
inline const std::string& DownstreamMediaFrame::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void DownstreamMediaFrame::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* DownstreamMediaFrame::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* DownstreamMediaFrame::release_payload() {
  // @@protoc_insertion_point(field_release:cams.api.hub.DownstreamMediaFrame.payload)
  return _impl_.payload_.Release();
}
inline void DownstreamMediaFrame::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.DownstreamMediaFrame.payload)
}

// -------------------------------------------------------------------

// RegisterRequest

// .cams.api.hub.StreamId id = 1;
inline bool RegisterRequest::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool RegisterRequest::has_id() const {
  return _internal_has_id();
}
inline void RegisterRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::cams::api::hub::StreamId& RegisterRequest::_internal_id() const {
  const ::cams::api::hub::StreamId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::cams::api::hub::StreamId&>(
      ::cams::api::hub::_StreamId_default_instance_);
}
inline const ::cams::api::hub::StreamId& RegisterRequest::id() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.RegisterRequest.id)
  return _internal_id();
}
inline void RegisterRequest::unsafe_arena_set_allocated_id(
    ::cams::api::hub::StreamId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cams.api.hub.RegisterRequest.id)
}
inline ::cams::api::hub::StreamId* RegisterRequest::release_id() {
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cams::api::hub::StreamId* RegisterRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:cams.api.hub.RegisterRequest.id)
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::cams::api::hub::StreamId* RegisterRequest::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cams::api::hub::StreamId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::cams::api::hub::StreamId* RegisterRequest::mutable_id() {
  ::cams::api::hub::StreamId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.RegisterRequest.id)
  return _msg;
}
inline void RegisterRequest::set_allocated_id(::cams::api::hub::StreamId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.RegisterRequest.id)
}

// -------------------------------------------------------------------

// PlayRequest

// .cams.api.hub.StreamId id = 1;
inline bool PlayRequest::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool PlayRequest::has_id() const {
  return _internal_has_id();
}
inline void PlayRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::cams::api::hub::StreamId& PlayRequest::_internal_id() const {
  const ::cams::api::hub::StreamId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::cams::api::hub::StreamId&>(
      ::cams::api::hub::_StreamId_default_instance_);
}
inline const ::cams::api::hub::StreamId& PlayRequest::id() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.PlayRequest.id)
  return _internal_id();
}
inline void PlayRequest::unsafe_arena_set_allocated_id(
    ::cams::api::hub::StreamId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cams.api.hub.PlayRequest.id)
}
inline ::cams::api::hub::StreamId* PlayRequest::release_id() {
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cams::api::hub::StreamId* PlayRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:cams.api.hub.PlayRequest.id)
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::cams::api::hub::StreamId* PlayRequest::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cams::api::hub::StreamId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::cams::api::hub::StreamId* PlayRequest::mutable_id() {
  ::cams::api::hub::StreamId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.PlayRequest.id)
  return _msg;
}
inline void PlayRequest::set_allocated_id(::cams::api::hub::StreamId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.PlayRequest.id)
}

// -------------------------------------------------------------------

// PauseRequest

// .cams.api.hub.StreamId id = 1;
inline bool PauseRequest::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool PauseRequest::has_id() const {
  return _internal_has_id();
}
inline void PauseRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::cams::api::hub::StreamId& PauseRequest::_internal_id() const {
  const ::cams::api::hub::StreamId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::cams::api::hub::StreamId&>(
      ::cams::api::hub::_StreamId_default_instance_);
}
inline const ::cams::api::hub::StreamId& PauseRequest::id() const {
  // @@protoc_insertion_point(field_get:cams.api.hub.PauseRequest.id)
  return _internal_id();
}
inline void PauseRequest::unsafe_arena_set_allocated_id(
    ::cams::api::hub::StreamId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cams.api.hub.PauseRequest.id)
}
inline ::cams::api::hub::StreamId* PauseRequest::release_id() {
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cams::api::hub::StreamId* PauseRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:cams.api.hub.PauseRequest.id)
  
  ::cams::api::hub::StreamId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::cams::api::hub::StreamId* PauseRequest::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cams::api::hub::StreamId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::cams::api::hub::StreamId* PauseRequest::mutable_id() {
  ::cams::api::hub::StreamId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cams.api.hub.PauseRequest.id)
  return _msg;
}
inline void PauseRequest::set_allocated_id(::cams::api::hub::StreamId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cams.api.hub.PauseRequest.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hub
}  // namespace api
}  // namespace cams

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cams::api::hub::DownstreamCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cams::api::hub::DownstreamCommandType>() {
  return ::cams::api::hub::DownstreamCommandType_descriptor();
}
template <> struct is_proto_enum< ::cams::api::hub::DownstreamMediaFrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cams::api::hub::DownstreamMediaFrameType>() {
  return ::cams::api::hub::DownstreamMediaFrameType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hub_2eproto
